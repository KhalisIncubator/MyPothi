/* eslint-disable no-restricted-syntax */
// saved Pothis database
import Pothis from '../Defaults';
import localRealm from './RealmSchemas';

import generateID from './Functions';
import {
  storedPothi, entryObj, Modification, ModType, Element,
} from '../../types/types';


// global db functions
/**
 * looks to see if db has any objects in
 * @returns {boolean} isEmpty
 */
const isDataEmpty = () => localRealm.empty;

/**
 * path of the realm
 * @returns {string} path
 */
const realmPath = () => localRealm.path;

/**
 * delete all objects in database
 */
const emptyDB = () => {
  localRealm.deleteAll();
};

/**
 * if the realm is empty, then it is populated with the items in {@link ../defaults}
 */
const populateData = () => {
  if ( localRealm.empty ) {
    Pothis.forEach( ( pothi ) => {
      localRealm.write( () => {
        const newPothi = localRealm.create( 'Pothi', {
          name: pothi.name,
          items: [],
          index: pothi.index,
          pothiID: pothi.pothiID,
        } );
        pothi.items.forEach( ( item ) => {
          newPothi.items.push( item );
        } );
      } );
    } );
  }
};

export {
  isDataEmpty, realmPath, emptyDB, populateData,
};

// pothi functions
/**
 * fetches an array of all the pothis' names (so that top level app state is not managing large amounts of data)
 */
const fetchAllPothis = (): string[][] => {
  const names = [];
  if ( isDataEmpty() ) {
    populateData();
  }
  const pothis = localRealm.objects<storedPothi>( 'Pothi' ).sorted( 'index' );
  pothis.forEach( ( pothi ) => {
    const { name, pothiID } = pothi;
    names.push( [ name, pothiID ] );
  } );
  return names;
};
const getFullPothis = () => localRealm.objects<storedPothi>( 'Pothi' ).sorted( 'index' );
/**
 *
 * @param {string} currentPothi the name of the current pothi
 * @returns {storedPothi} the stored pothi object with the name property provided
 */
const findPothi = ( currentPothi, pothiID ) => {
  const filter = `name == "${currentPothi}" AND pothiID == "${pothiID}"`;
  const [ pothi ] = localRealm.objects<storedPothi>( 'Pothi' ).filtered( filter );
  return pothi;
};
const updatePothi = ( currentName: string, pothiID: string ) => {
  const pothi = findPothi( currentName, pothiID );
  return ( key: string, value: any ) => {
    localRealm.write( () => {
      pothi[key] = value;
      pothi.items.forEach( ( item ) => { item.parentPothi = value; } );
    } );
  };
};
const createNewPothi = ( name ) => {
  const newID = generateID();
  localRealm.write( () => {
    localRealm.create( 'Pothi', {
      name,
      items: [],
      pothiID: newID,
      index: fetchAllPothis().length,
    } );
  } );
};

/**
 *
 * @param name string of name
 * @param pothiID string of id, generated by nanoid
 */
const deleteGukta = ( name, pothiID ) => {
  const pothi = findPothi( name, pothiID );
  localRealm.write( async () => {
    const { index } = pothi;
    for ( const item of pothi.items ) {
      for ( const mod of item.mods ) {
        localRealm.delete( mod );
      }
      for ( const line of item.lines ) {
        localRealm.delete( line );
      }
      localRealm.delete( item );
    }
    localRealm.delete( pothi );
    const pothisAfter = getFullPothis().slice( index );
    pothisAfter.forEach( ( nextPothi ) => {
      nextPothi.index -= 1;
    } );
  } );
};

export {
  fetchAllPothis, findPothi, updatePothi, createNewPothi, deleteGukta,
};

// entry/item related functions

/**
 * @param { string } parentP name of the parent pothi
 * @param { string } entryID id of the entry, generated by nanoid
 * @returns { entryObj } item
 */
const findItem = ( parentP, entryID ) => {
  const filter = `parentPothi == "${parentP}" AND entryID == "${entryID}"`;
  const [ item ] = localRealm.objects<entryObj>( 'Entry' ).filtered( filter );
  return item;
};
/**
 *
 * @param {string} currentPothi the name of the current pothi
 * @param {string} pothiID id string of the pothi, generated by nanoid
 * @returns {entryObj[]} array of the items
 */
const getCurrentItems = ( currentPothi, pothiID ) => {
  let pothi;
  if ( currentPothi && pothiID ) {
    pothi = findPothi( currentPothi, pothiID );
  } else {
    [ pothi ] = localRealm.objects( 'Pothi' );
  }

  const items: entryObj[] = [];
  pothi.items.sorted( 'index' ).forEach( ( item ) => {
    if ( item.isValid() ) {
      items.push( item );
    }
  } );
  return items;
};

/**
 *
 * @param {string} currentPothi the name of the current pothi
 * @param {number} id shabadID/baniID of the new entry
 * @param {string} mainLine the main line identifier of the shabad
 * @param {pothiEntry} type shabad or bani
 */
const addToPothi = ( currentPothi, pothiID, id, mainLine, lines, type, info? ) => {
  const pothi: storedPothi = findPothi( currentPothi, pothiID );
  const { source, raag, writer } = info;
  const newID = generateID();
  localRealm.write( () => {
    const entry = localRealm.create( 'Entry', {
      shabadId: id,
      mainLine,
      type,
      parentPothi: currentPothi,
      lines,
      mods: [],
      index: pothi.items.length,
      entryID: newID,
      source,
      raag,
      writer,
    } );
    pothi.items.push( entry );
  } );
};

/**
 *
 * @param currentPothi string name of current pothi
 * @param itemId string id of the item, generated by nanoid
 */
const removeFromPothi = ( currentPothi, itemId, currentPothiID ) => {
  const item = findItem( currentPothi, itemId );
  localRealm.write( () => {
    const { index } = item;
    for ( const mod of item.mods ) {
      localRealm.delete( mod );
    }
    for ( const line of item.lines ) {
      localRealm.delete( line );
    }
    localRealm.delete( item );
    const itemsAfter = getCurrentItems( currentPothi, currentPothiID ).slice( index );
    itemsAfter.forEach( ( nextItem ) => {
      nextItem.index -= 1;
    } );
  } );
};

const getLastItem = () => {
  const all = localRealm.objects<entryObj>( 'Entry' ).sorted( 'index' );
  return all[all.length - 1];
};
const undoCreation = () => {
  const lastPothi = getLastItem();
  localRealm.write( () => {
    for ( const mod of lastPothi.mods ) {
      localRealm.delete( mod );
    }
    for ( const line of lastPothi.lines ) {
      localRealm.delete( line );
    }
    localRealm.delete( lastPothi );
  } );
};
export {
  getCurrentItems, addToPothi, removeFromPothi, undoCreation,
};

// modification related functions

const getAllModifications = ( parentID: string ) => {
  const fetched = localRealm.objects<Modification>( 'Modification' ).filtered( `parentID == "${parentID}"` );
  const mapped: Modification[] = fetched.map( ( mod ) => mod );
  return mapped;
};
const getModification = ( lineid: number, element: Element, modID: string ) => {
  const filter = `lineID == "${lineid}" AND element == "${element}" AND modID == "${modID}"`;
  const [ mod ] = localRealm.objects<Modification>( 'Modification' ).filtered( filter );
  return mod;
};
const getModWithParent = ( lineid: number, element: Element, parentID: string ) => {
  const filter = `lineID == "${lineid}" AND element == "${element}" AND parentID == "${[ parentID ]}"`;
  const [ mod ] = localRealm.objects<Modification>( 'Modification' ).filtered( filter );
  return mod;
};
const existsModification = ( lineid: number, element: Element, parentID: string ) => getModWithParent( lineid, element, parentID ) !== undefined;
const createModification = ( currentName: string, parentID: string ) => {
  const item = findItem( currentName, parentID );
  return ( lineid: number, element: Element, type: ModType, value:any ) => {
    const modID = generateID();
    const newMod = {
      lineID: lineid,
      element,
      modID,
      parentID,
      [type]: value,
    };
    localRealm.write( () => {
      const mod = localRealm.create( 'Modification', {
        ...newMod,
      } );
      item.mods.push( mod );
    } );
  };
};
const editModification = (
  lineid: number,
  element: Element,
  parentID: string,
  newMod: string,
  value: string | boolean,
) => {
  let mod = getModWithParent( lineid, element, parentID );
  localRealm.write( () => {
    mod[newMod] = value;
  } );
};
const deleteModification = ( lineid: number, element: Element, parentID: string ) => {
  const mod = getModWithParent( lineid, element, parentID );
  localRealm.write( () => {
    localRealm.delete( mod );
  } );
};

export {
  getAllModifications, getModification, existsModification, createModification, editModification, deleteModification, getModWithParent,
};
